# Terraform Structure Guide

## File Organization

Resources are organized by dependency order using numeric prefixes:

```
00_* - Foundation (data sources, validations)
01_* - Networking (VPC, security groups)
02_* - Data Layer (S3, Redis, TimescaleDB)
03_* - Messaging & Monitoring (SNS, SQS, CloudWatch)
04_* - Compute (ECS tasks, services)
05_* - Supporting Services (bastion, IAM, secrets)
```

## Adding New Resources

### Choose the Correct Prefix

- **00_**: Data sources or provider validations only
- **01_**: Networking resources (subnets, route tables, NAT gateways)
- **02_**: Storage and database resources
- **03_**: Pub/sub queues, topics, or CloudWatch alarms
- **04_**: Application workloads (ECS tasks, services, task definitions)
- **05_**: Auxiliary services (IAM roles, Secrets Manager, bastion hosts)

### File Naming Convention

Pattern: `{prefix}_{resource_category}.tf`

Examples:
- `02_dynamodb.tf` - DynamoDB tables (Data Layer)
- `04_ecs_api_worker.tf` - New ECS service (Compute)
- `05_iam_lambda.tf` - Lambda execution role (Supporting)

### Within a File

1. **Group related resources together**
2. **Use comments to separate logical sections**:
   ```terraform
   # -----------------------------------------------------------------------------
   # Section Name
   # -----------------------------------------------------------------------------
   ```
3. **Order**: resource definitions, then data sources, then outputs
4. **Dependencies**: Use `depends_on` explicitly when order matters

## Resource Naming

### Terraform Resource Names

Use descriptive, hierarchical names:
```terraform
resource "aws_ecs_task_definition" "watcher" { }       # Good
resource "aws_ecs_task_definition" "task1" { }         # Bad
```

### AWS Resource Names

Use the standard prefix pattern:
```terraform
name = "${local.prefix}-resource-type${local.resource_suffix}"
```

Examples:
- `${local.prefix}-watcher-task${local.resource_suffix}`
- `${local.prefix_lowercase}-vpc${local.resource_suffix}`

Use `local.prefix_lowercase` for resources requiring lowercase names (S3, ECR).

## State Management

### Main Infrastructure (`infra/`)

- Backend: S3 + DynamoDB table per environment
- Manages: VPC, ECS, databases, IAM policies
- Apply with: `make tf-apply ENV=sentinelstaging`

### Bootstrap Infrastructure (`infra/bootstrap/`)

- Backend: Local state file (checked into git for dev/staging only)
- Manages: State bucket, DynamoDB locks, initial secrets
- Apply with: `make tf-bootstrap ENV=sentinelstaging`

**Critical**: Never manage bootstrap resources in main state. They must exist before main state can initialize.

### Version Control

**Files to commit**:
- ✅ `.terraform.lock.hcl` - Provider version lock file (both `infra/` and `infra/bootstrap/`)
- ✅ `*.tf` - All Terraform configuration files
- ✅ `environments/*.tfvars` - Environment-specific configurations
- ✅ `environments/*.backend.hcl` - Backend configurations

**Files to ignore** (already in `.gitignore`):
- ❌ `.terraform/` - Provider plugins cache (regenerated by `tofu init`)
- ❌ `*.tfstate` - State files for bootstrap (dev/staging use local state, prod should not)
- ❌ `terraform.tfvars` - Local overrides with credentials
- ❌ `*.auto.tfvars` - Auto-loaded local overrides

**Why commit lock files**: Ensures consistent provider versions across all developers and CI/CD environments. See [infrastructure_deployment_workflow.md](./infrastructure_deployment_workflow.md#provider-lock-files--version-control) for details.

## Common Patterns

### Environment-Specific Values

Define in `environments/{env}.tfvars`:
```terraform
environment = "sentinelstaging"
tigerdata_milli_cpu = 2000
tigerdata_memory_gb = 8
```

### Conditional Resources

Use `count` for optional resources:
```terraform
resource "aws_instance" "bastion" {
  count = var.enable_bastion ? 1 : 0
  # ...
}
```

### Cross-File References

Reference resources from other files directly:
```terraform
vpc_id = aws_vpc.main.id
subnet_ids = aws_subnet.private[*].id
```

## Quick Reference

| Type | Prefix | Examples |
|------|--------|----------|
| Data sources | 00_ | `00_data_sources.tf` |
| Networking | 01_ | `01_vpc.tf`, `01_security_groups.tf` |
| Data stores | 02_ | `02_tigerdata.tf`, `02_s3.tf` |
| Messaging | 03_ | `03_messaging.tf` |
| Compute | 04_ | `04_ecs_watcher.tf` |
| Support | 05_ | `05_secrets.tf`, `05_bastion.tf` |

## When to Create a New File

Create a new file when:
- Adding a distinct service or component (e.g., new ECS task)
- An existing file exceeds ~200 lines
- Resources have minimal coupling with existing files

Add to an existing file when:
- Extending an existing component (e.g., new IAM policy for existing role)
- Resources are tightly coupled (e.g., SNS topic + subscriptions)
